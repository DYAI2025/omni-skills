FILETREE  ai-lead-story-mapping/ ├─ SKILL.md ├─ references/ │  ├─ glossary.md │  ├─ mapping-patterns.md │  ├─ slicing-strategies.md │  ├─ workshop-facilitation.md │  └─ acceptance-criteria-examples.md ├─ scripts/ │  ├─ story_map_validator.py │  ├─ slice_suggester.py │  ├─ export_backlog_csv.py │  └─ map_to_mermaid.py └─ assets/    ├─ templates/    │  ├─ story-map-canvas.md    │  ├─ story-map.json    │  ├─ story-slice.md    │  ├─ user-journey.md    │  └─ ac-template.md    └─ examples/       ├─ example-story-map.json       ├─ example-backlog.csv       └─ example-slices.md path: ai-lead-story-mapping/SKILL.md --- name: ai-lead-story-mapping description: Erstellt und pflegt User‑Story‑Maps als Sub‑Skill des AI‑Lead‑Orchestrators; führt Teams von Ziel & Persona über Backbone/Activities und vertikale Priorisierung zum Slicing (MVP/Walking Skeleton) und exportiert testbare Backlog‑Artefakte (JSON/CSV/Mermaid). ---  # Story Mapping Sub‑Skill (für AI Lead)  > **Kernidee:** Story Mapping verwandelt ein flaches Backlog in eine zweidimensionale, kontextreiche Landkarte mit einer horizontalen Reise (Backbone) und vertikaler Wichtigkeit—und macht so MVP & Releases über **Slicing** sichtbar.   ## Wann verwenden - Wenn Nutzerziele, Backbone‑Aktivitäten und Schritte **sichtbar** gemacht und in **testbare Stories & Slices** überführt werden sollen. :contentReference[oaicite:1]{index=1}   - Wenn MVP/Releases als **horizontale Cut‑Lines** (Slicing) geplant werden, sodass der erste Slice ein **Walking Skeleton** (dünnster, aber end‑to‑end nutzbarer Weg) ist. :contentReference[oaicite:2]{index=2}   - Wenn der AI‑Lead Orchestrator methodische Sub‑Skills steuert (z. B. Story Mapping → Priorisierung → Delivery), und strukturierte Artefakte benötigt (JSON/CSV/Mermaid). :contentReference[oaicite:3]{index=3}  ## Inputs (vom Orchestrator) - **context.product** (Name, Domäne), **context.actor/persona**, **context.goal/outcome**, **context.kpis[]**   - **constraints** (Timebox, Non‑Goals, Policies)   - **seed_items** (vorhandene Stories/Backlog‑Tickets, optional)   - **work_mode**: `workshop|async` (für Moderationstipps siehe *Workshop‑Facilitation*). :contentReference[oaicite:4]{index=4}  ## Outputs (an Orchestrator) - **story_map.json** (Activities/Steps/Stories inkl. AC)   - **slices.md** (MVP + Folge‑Releases, inkl. Outcome/Metriken) :contentReference[oaicite:5]{index=5}   - **backlog.csv** (Export zur Priorisierung z. B. WSJF/RICE im AI‑Lead‑Flow)   - **storymap.mmd** (Mermaid zur Visualisierung)   - **validation_report** (Format/Referenz‑Checks)  ## Aktionen (Sub‑Skill‑Contract) - `story_map.create(context, seed_items?) -> story_map.json`   - `story_map.enrich(story_map.json, hints?) -> story_map.json`   - `story_map.validate(story_map.json) -> validation_report`   - `story_map.slice(story_map.json, strategy?) -> slices.md` :contentReference[oaicite:6]{index=6}   - `story_map.visualize(story_map.json) -> storymap.mmd`   - `story_map.export_backlog(story_map.json) -> backlog.csv`  ## Workflow/Anweisungen 1. **Vorbereitung (Framing)**      Ziel/Outcome und Persona klären (Elevator Pitch), Teilnehmer cross‑funktional festlegen (7–10 ideal), physisch/digital planen. :contentReference[oaicite:7]{index=7}   2. **Backbone aufbauen (horizontale Achse)**      Große Benutzeraktivitäten von links nach rechts in chronologischer Reihenfolge. **Horizontale Frage:** Haben wir die gesamte Reise? :contentReference[oaicite:8]{index=8}   3. **Stories sammeln (vertikale Achse)**      Unter jede Aktivität konkrete Stories/Tasks hängen; nach oben die Must‑haves (INVEST); Alternativen darunter (**„oder“‑Lesen**). **Vertikale Frage:** Was ist je Schritt am wichtigsten? :contentReference[oaicite:9]{index=9}   4. **Strukturieren, Lücken/Abhängigkeiten aufdecken**      Gemeinsames „Durchwandern“ der Map deckt Gaps, technische Stories und Abhängigkeiten auf; Entwickler*innen müssen anwesend sein. :contentReference[oaicite:10]{index=10}   5. **Slicing & Releases planen**      Nach vertikaler Priorisierung horizontale **Cut‑Lines** ziehen: oberster Slice = **MVP/Walking Skeleton** (mind. eine Story aus jedem kritischen Backbone‑Schritt), weitere Slices fügen „Fleisch“ hinzu. Jede Slice mit Ziel/Metriken testbar halten. :contentReference[oaicite:11]{index=11}   6. **Artefakte erzeugen**      Validator, CSV‑Export, Mermaid‑Diagramm ausführen und an AI‑Lead übergeben.  ## Leitprinzipien - **Value‑Delivery statt Feature‑Fabrik:** Fokus auf Nutzerproblem & vollständige End‑to‑End‑Erfahrung (CPE) statt „Top‑5‑Features‑Liste“. :contentReference[oaicite:12]{index=12}   - **MVP = Walking Skeleton:** Dünnster, funktional vollständiger Durchstich durch die Journey. :contentReference[oaicite:13]{index=13}   - **Lebendes Artefakt:** Map fortlaufend pflegen, nicht „wegwerfen“. :contentReference[oaicite:14]{index=14}  ## CLI‑Nutzung (lokal) ```bash # Validieren python scripts/story_map_validator.py assets/examples/example-story-map.json  # Slices vorschlagen (Happy‑Path‑Heuristik) python scripts/slice_suggester.py assets/examples/example-story-map.json --out assets/examples/example-slices.md  # Backlog exportieren python scripts/export_backlog_csv.py assets/examples/example-story-map.json --out assets/examples/example-backlog.csv  # Mermaid erzeugen python scripts/map_to_mermaid.py assets/examples/example-story-map.json > storymap.mmd Ausgabeformat story_map.json gemäß Template (Activities/Steps/Stories, AC im Gherkin‑Stil)  slices.md (MVP/Follow‑Up mit Outcome & Metriken)   backlog.csv (id,title,description,depends_on,actor,goal,activity,step,pattern,effort,reach,impact,confidence,bv,tc,rr,js)  storymap.mmd Mermaid Flowchart  Beispiele Siehe assets/examples/ für eine Onboarding‑Map mit MVP‑Slice und CSV‑Export (inkl. Abhängigkeiten & ACs).  Hinweise & Quellen Definition, Anatomie und Nutzen des Story Mappings (Backbone horizontal, Priorität vertikal; Unterschied zu flachem Backlog; MVP/Slicing/Walking Skeleton; Workshop‑Vorgehen & Facilitation) basieren auf den beigefügten Materialien.   ---  # path: ai-lead-story-mapping/references/glossary.md ```md # Glossar Story Mapping  - **Persona/Actor** – primärer Nutzer oder Stakeholder des Flows.   - **Goal/Outcome** – Nutzerintention auf Ergebnis‑Ebene.   - **Activity (Backbone)** – chronologische, grobe Schritte der Nutzerreise (horizontale Achse). :contentReference[oaicite:17]{index=17} - **Step** – konkreter Teil einer Aktivität.   - **Story** – testbare, nutzerzentrierte Funktionseinheit (INVEST) mit ACs.   - **Vertical Priority** – Wichtigkeit/Alternativen je Schritt (vertikale Achse). :contentReference[oaicite:18]{index=18} - **Slice (Cut‑Line)** – horizontale Linie, die Releases/MVPs sichtbar macht. :contentReference[oaicite:19]{index=19} - **MVP / Walking Skeleton** – dünnster, aber funktional vollständiger End‑to‑End‑Weg (Complete Product Experience). :contentReference[oaicite:20]{index=20} - **Shared Understanding** – gemeinsames Verständnis durch kuratierte Konversation im Workshop. :contentReference[oaicite:21]{index=21} path: ai-lead-story-mapping/references/mapping-patterns.md # Mapping‑ & Cutting‑Patterns  ## Mapping (vom Ziel zur Story) 1) **Goal → Activities (3–7)** – erst die gesamte Reise sichtbar machen. :contentReference[oaicite:22]{index=22}   2) **Activity → Steps (3–7)**   3) **Steps → Stories** (mind. 1 pro Step; INVEST + ACs)   4) **Gaps/Dependencies walken** – Map narrativ durchgehen, Risiken/technische Stories ergänzen. :contentReference[oaicite:23]{index=23}  ## Cutting (vertikale Slices) - **End‑to‑End‑Slice** – minimaler Durchstich Start→Ziel (MVP). :contentReference[oaicite:24]{index=24}   - **Risk‑First‑Slice** – unsichere Regel/Integration früh isolieren.   - **Value‑First‑Slice** – höchster Kundennutzen zuerst.   - **Interface‑Slice** – UI‑Weg mit Backend‑Stub.   - **Rule‑Slice** – einzelne Geschäftsregel aktiv.    **Heuristiken** - Pro Slice: 1 Goal, 1–2 Activities, 2–4 Steps, 1–3 Stories.   - Nach 2–3 Slices: Konsistenz‑Review & Outcome‑Check.   path: ai-lead-story-mapping/references/slicing-strategies.md # Slicing‑Strategien (Releases planen)  - **MVP zuerst (Walking Skeleton)** – pro kritischem Backbone‑Schritt mind. eine Story; liefert eine durchgängige Experience (CPE). :contentReference[oaicite:25]{index=25}   - **Folge‑Slices „Fleisch hinzufügen“** – Alternativen/Komfortfunktionen nachziehen; weiterhin testbar. :contentReference[oaicite:26]{index=26}   - **Opening/Mid/End‑Game** pro Release‑Slice (Strategie & Ziele/Metriken definieren). :contentReference[oaicite:27]{index=27} path: ai-lead-story-mapping/references/workshop-facilitation.md # Workshop‑Facilitation (Story Mapping)  - **Framing** – Elevator Pitch, Problem/Personas/Nutzen klären. :contentReference[oaicite:28]{index=28}   - **Team** – cross‑funktional (PO/Stakeholder, Entwicklung, UX), ca. 7–10 (oder 5–8), Entwickler*innen müssen dabei sein. :contentReference[oaicite:29]{index=29}   - **Format** – physisch (Whiteboard, Haftnotizen) oder digital (Miro/Mural/Boards).    - **Ablauf (vereinfacht)**     1) Backbone erstellen (Big Picture, chronologisch) :contentReference[oaicite:31]{index=31}     2) Stories sammeln & priorisieren (Must‑haves nach oben) :contentReference[oaicite:32]{index=32}     3) Map „abwandernd“ prüfen → Lücken/Dependencies sichtbar :contentReference[oaicite:33]{index=33}     4) **Slicing** ziehen → MVP + Releases (Outcomes/Metriken) :contentReference[oaicite:34]{index=34}   - **Lebendiges Artefakt** – Map nach jedem Sprint/Release pflegen. :contentReference[oaicite:35]{index=35} path: ai-lead-story-mapping/references/acceptance-criteria-examples.md # Akzeptanzkriterien – Beispiele (Gherkin)  - **Given** ich bin Neukunde     **When** ich registriere mich mit E‑Mail und Passwort     **Then** erhalte ich eine Bestätigungs‑E‑Mail  - **Given** ich gebe ein schwaches Passwort ein     **When** ich sende das Formular     **Then** sehe ich Hinweise zur Passwortstärke und kann nicht fortfahren  - **Given** ich starte als Erstnutzer     **When** ich öffne die Guided‑Tour     **Then** sehe ich 3 Hinweise und kann sie beenden path: ai-lead-story-mapping/scripts/story_map_validator.py #!/usr/bin/env python3 """ Story Map Validator Prüft das JSON-Format gemäß Template (product, actor, goal, kpis, activities, stories, version). Exit 0 bei Erfolg, sonst != 0 mit Fehlermeldung. """ import sys, json  REQ_TOP = ["product", "actor", "goal", "activities", "stories", "version"] REQ_ACTIVITY = ["id", "title", "steps"] REQ_STEP = ["id", "title"] REQ_STORY = ["id", "title", "activity_id", "step_id", "ac"]  def die(msg, code=1):     print(f"[story-map-validator] {msg}", file=sys.stderr); sys.exit(code)  def main():     if len(sys.argv) < 2:         die("Bitte Pfad zur Story-Map-JSON angeben (z. B. assets/examples/example-story-map.json).")     path = sys.argv[1]     try:         with open(path, encoding="utf-8") as f:             data = json.load(f)     except Exception as e:         die(f"Kann JSON nicht lesen: {e}")      for k in REQ_TOP:         if k not in data:             die(f"Pflichtfeld fehlt: {k}")      if not isinstance(data["activities"], list) or not data["activities"]:         die("activities muss nicht-leere Liste sein.")     if not isinstance(data["stories"], list) or not data["stories"]:         die("stories muss nicht-leere Liste sein.")      act_index = {}     step_index = {}     for a in data["activities"]:         for k in REQ_ACTIVITY:             if k not in a:                 die(f"Aktivität unvollständig: {a}")         if not isinstance(a["steps"], list) or not a["steps"]:             die(f"steps fehlen in Aktivität: {a.get('id')}")         act_index[a["id"]] = a         for s in a["steps"]:             for k in REQ_STEP:                 if k not in s:                     die(f"Schritt unvollständig: {s}")             if s["id"] in step_index:                 die(f"Doppelte step_id: {s['id']}")             step_index[s["id"]] = {"step": s, "activity_id": a["id"]}      seen_ids = set()     for st in data["stories"]:         for k in REQ_STORY:             if k not in st:                 die(f"Story unvollständig: {st}")         if st["id"] in seen_ids:             die(f"Doppelte Story-ID: {st['id']}")         seen_ids.add(st["id"])         if st["activity_id"] not in act_index:             die(f"Unbekannte activity_id: {st['activity_id']}")         if st["step_id"] not in step_index:             die(f"Unbekannte step_id: {st['step_id']}")         if not isinstance(st["ac"], list) or not st["ac"]:             die(f"AC fehlen in Story: {st['id']}")      print("[story-map-validator] valid")  if __name__ == "__main__":     main() path: ai-lead-story-mapping/scripts/slice_suggester.py #!/usr/bin/env python3 """ Slice Suggester Erzeugt einfache Vorschläge für vertikale Slices aus einer Story-Map-JSON.  Heuristik: - MVP (Slice 1) = Walking Skeleton: pro Aktivität pro Step die erste passende Story (falls vorhanden) - Reststories werden gleichmäßig auf Slice 2/3 verteilt """ import sys, json, math from collections import defaultdict  def main():     if len(sys.argv) < 2:         print("Usage: slice_suggester.py <story_map.json> [--out slices.md]", file=sys.stderr)         sys.exit(1)     path = sys.argv[1]     out = None     if "--out" in sys.argv:         i = sys.argv.index("--out")         if i+1 < len(sys.argv):             out = sys.argv[i+1]      data = json.load(open(path, encoding="utf-8"))     activities = data["activities"]     stories = data["stories"]      # Index Stories per step     by_step = defaultdict(list)     for st in stories:         by_step[st["step_id"]].append(st)      # MVP: für jeden Step der Aktivität die erste Story (falls vorhanden)     mvp_ids = set()     mvp_list = []     for a in activities:         for s in a["steps"]:             candidates = by_step.get(s["id"], [])             if candidates:                 pick = candidates[0]                 if pick["id"] not in mvp_ids:                     mvp_ids.add(pick["id"])                     mvp_list.append(pick)      # Reststories     rest = [st for st in stories if st["id"] not in mvp_ids]     chunks = max(1, 2 if len(rest) <= 8 else 3)     size = math.ceil(len(rest) / chunks) if rest else 0     rest_slices = [rest[i:i+size] for i in range(0, len(rest), size)] if rest else []      md = []     md.append("# Slice‑Vorschläge\n")     md.append("## Slice 1 – MVP (Walking Skeleton)\n")     if mvp_list:         for st in mvp_list:             md.append(f"- {st['id']}: {st['title']} (activity={st['activity_id']}, step={st['step_id']})")     else:         md.append("- <keine Stories>")     md.append("")      for idx, sl in enumerate(rest_slices, start=2):         md.append(f"## Slice {idx}\n")         if sl:             for st in sl:                 md.append(f"- {st['id']}: {st['title']} (activity={st['activity_id']}, step={st['step_id']})")         else:             md.append("- <keine Stories>")         md.append("")      text = "\n".join(md)     if out:         with open(out, "w", encoding="utf-8") as f:             f.write(text)         print(f"[slice-suggester] geschrieben: {out}")     else:         print(text)  if __name__ == "__main__":     main() path: ai-lead-story-mapping/scripts/export_backlog_csv.py #!/usr/bin/env python3 """ Exportiert Stories aus story_map.json in eine Backlog-CSV.  Spalten: id,title,description,depends_on,actor,goal,activity,step,pattern,effort,reach,impact,confidence,bv,tc,rr,js """ import sys, json, csv  FIELDS = ["id","title","description","depends_on","actor","goal","activity","step",           "pattern","effort","reach","impact","confidence","bv","tc","rr","js"]  def main():     if len(sys.argv) < 2:         print("Usage: export_backlog_csv.py <story_map.json> --out <backlog.csv>", file=sys.stderr)         sys.exit(1)     path = sys.argv[1]     out = None     if "--out" in sys.argv:         i = sys.argv.index("--out")         if i+1 < len(sys.argv): out = sys.argv[i+1]      data = json.load(open(path, encoding="utf-8"))     activities = {a["id"]: a for a in data["activities"]}     step_title = {}     for a in data["activities"]:         for s in a["steps"]:             step_title[s["id"]] = s["title"]      rows = []     for st in data["stories"]:         row = {k:"" for k in FIELDS}         row["id"] = st.get("id","")         row["title"] = st.get("title","")         row["description"] = st.get("description","")         row["depends_on"] = st.get("depends_on","")         row["actor"] = data.get("actor","")         row["goal"] = data.get("goal","")         row["activity"] = activities.get(st["activity_id"],{}).get("title","")         row["step"] = step_title.get(st["step_id"],"")         row["pattern"] = st.get("pattern","Workflow")         # ökonomische Felder optional vorbelegen (0/leer)         for k in ["effort","reach","impact","confidence","bv","tc","rr","js"]:             row[k] = st.get(k, 0)         rows.append(row)      if not out:         print("[export-backlog] Hinweis: --out <backlog.csv> nicht angegeben, schreibe nach stdout")         writer = csv.DictWriter(sys.stdout, fieldnames=FIELDS)         writer.writeheader()         for r in rows: writer.writerow(r)     else:         with open(out, "w", newline="", encoding="utf-8") as f:             writer = csv.DictWriter(f, fieldnames=FIELDS)             writer.writeheader()             for r in rows:                 writer.writerow(r)         print(f"[export-backlog] geschrieben: {out}")  if __name__ == "__main__":     main() path: ai-lead-story-mapping/scripts/map_to_mermaid.py #!/usr/bin/env python3 """ Erzeugt ein Mermaid-Flowchart (flowchart LR) aus story_map.json. - Subgraph je Aktivität - Kanten in Steps-Reihenfolge """ import sys, json  def node_id(activity_id, step_id):     return f"{activity_id}_{step_id}".replace("-", "_")  def main():     if len(sys.argv) < 2:         print("Usage: map_to_mermaid.py <story_map.json>", file=sys.stderr)         sys.exit(1)      data = json.load(open(sys.argv[1], encoding="utf-8"))     acts = data["activities"]      lines = []     lines.append("flowchart LR")      # Subgraphs pro Aktivität     for a in acts:         lines.append(f"  subgraph {a['id']}[{a['title']}]")         # Nodes         for s in a["steps"]:             nid = node_id(a["id"], s["id"])             label = s["title"].replace('[','(').replace(']',')')             lines.append(f"    {nid}[{label}]")         # Edges in Reihenfolge         for i in range(len(a["steps"])-1):             s1, s2 = a["steps"][i], a["steps"][i+1]             n1, n2 = node_id(a["id"], s1["id"]), node_id(a["id"], s2["id"])             lines.append(f"    {n1} --> {n2}")         lines.append("  end")      print("\n".join(lines))  if __name__ == "__main__":     main() path: ai-lead-story-mapping/assets/templates/story-map-canvas.md # Story‑Map Canvas (Beispiel – kann direkt überschrieben werden)  ## Produkt & Ziel - **Produkt:** Onboarding 1.0 - **Actor/Persona:** Neukunde (B2C) - **Goal/Outcome:** Schnell registrieren und ersten Nutzen erleben - **KPIs:** Activation Rate (D1), Time to First Value (TTFV)  ## Backbone (Activities in Reihenfolge) 1) Registrieren   2) Erste Schritte & Hilfe  ## Steps je Activity (Beispiel) - **Registrieren:** E‑Mail & Passwort → Double‑Opt‑In   - **Erste Schritte & Hilfe:** Guided Tour → Erste Aufgabe abschließen  ## Stories (unter Steps, Must‑haves nach oben) - Formular E‑Mail/Passwort → Double‑Opt‑In → Guided Tour Overlay → Erste Aufgabe abschließen  ## Risiken & Abhängigkeiten - E‑Mail‑Zustellung, Spamfilter, Tracking‑Events  ## Slicing (Cut‑Lines) - **Slice 1 (MVP):** Minimaler End‑to‑End‑Weg durch alle Schritte   - **Slice 2+:** Komfortfunktionen/Alternativen path: ai-lead-story-mapping/assets/templates/story-map.json {   "version": "1.0",   "product": "Onboarding 1.0",   "actor": "Neukunde",   "goal": "Schnell registrieren und ersten Nutzen erleben",   "kpis": ["Activation Rate (D1)", "Time to First Value (TTFV)"],   "activities": [     {       "id": "A1",       "title": "Registrieren",       "steps": [         {"id": "S11", "title": "E-Mail & Passwort"},         {"id": "S12", "title": "Double-Opt-In"}       ]     },     {       "id": "A2",       "title": "Erste Schritte & Hilfe",       "steps": [         {"id": "S21", "title": "Guided Tour"},         {"id": "S22", "title": "Erste Aufgabe abschließen"}       ]     }   ],   "stories": [     {       "id": "ST1",       "title": "Formular E-Mail/Passwort",       "activity_id": "A1",       "step_id": "S11",       "description": "Basis-Registrierung",       "ac": ["Given Felder leer, When gültig ausfüllen, Then Konto angelegt"],       "pattern": "Workflow"     },     {       "id": "ST2",       "title": "Double-Opt-In",       "activity_id": "A1",       "step_id": "S12",       "description": "E-Mail-Bestätigung",       "depends_on": "ST1",       "ac": ["Given E-Mail gesendet, When Link klicken, Then Konto bestätigt"],       "pattern": "Rule"     },     {       "id": "ST3",       "title": "Guided Tour Overlay",       "activity_id": "A2",       "step_id": "S21",       "description": "Overlay mit 3 Tipps",       "ac": ["Given Erstlogin, When Start, Then 3 Hinweise sichtbar"],       "pattern": "Interface"     },     {       "id": "ST4",       "title": "Erste Aufgabe abschließen",       "activity_id": "A2",       "step_id": "S22",       "description": "Mini-Aufgabe mit Erfolgserlebnis",       "depends_on": "ST3",       "ac": ["Given Aufgabe offen, When erledigt, Then Erfolgsmeldung"],       "pattern": "Operation"     }   ] } path: ai-lead-story-mapping/assets/templates/story-slice.md # Release‑Slice (Vorlage)  - **Name:** Slice N – Kurzbezeichnung - **Ziel/Outcome:** (z. B. Aktivierungsrate D1 auf 30 %) - **Hypothese:** Wir glauben, dass … - **Metriken:** (Event/KPI, Messfenster) - **Scope (Stories):** ST… - **Risiken/Assumptions:** … - **DoD/AC:** Alle Stories besitzen geprüfte ACs, Telemetrie aktiv, Regression grün. path: ai-lead-story-mapping/assets/templates/user-journey.md # User Journey (Backbone/Activities)  1) …   2) …   3) …  > Jede Aktivität in Steps zerlegen und Stories darunter hängen (Must‑haves nach oben). path: ai-lead-story-mapping/assets/templates/ac-template.md # AC‑Template (Gherkin)  - **Given** … - **When** … - **Then** … path: ai-lead-story-mapping/assets/examples/example-story-map.json {   "version": "1.0",   "product": "Onboarding 1.0",   "actor": "Neukunde",   "goal": "Schnell registrieren und ersten Nutzen erleben",   "kpis": ["Activation Rate (D1)", "Time to First Value (TTFV)"],   "activities": [     {       "id": "A1",       "title": "Registrieren",       "steps": [         {"id": "S11", "title": "E-Mail & Passwort"},         {"id": "S12", "title": "Double-Opt-In"}       ]     },     {       "id": "A2",       "title": "Erste Schritte & Hilfe",       "steps": [         {"id": "S21", "title": "Guided Tour"},         {"id": "S22", "title": "Erste Aufgabe abschließen"}       ]     }   ],   "stories": [     {       "id": "ST1",       "title": "Formular E-Mail/Passwort",       "activity_id": "A1",       "step_id": "S11",       "description": "Basis-Registrierung",       "ac": ["Given Felder leer, When gültig ausfüllen, Then Konto angelegt"],       "pattern": "Workflow",       "effort": 2, "reach": 5000, "impact": 2, "confidence": 0.8, "bv": 8, "tc": 6, "rr": 3, "js": 3     },     {       "id": "ST2",       "title": "Double-Opt-In",       "activity_id": "A1",       "step_id": "S12",       "description": "E-Mail-Bestätigung",       "depends_on": "ST1",       "ac": ["Given E-Mail gesendet, When Link klicken, Then Konto bestätigt"],       "pattern": "Rule",       "effort": 1, "reach": 5000, "impact": 1, "confidence": 0.9, "bv": 6, "tc": 7, "rr": 3, "js": 2     },     {       "id": "ST3",       "title": "Guided Tour Overlay",       "activity_id": "A2",       "step_id": "S21",       "description": "Overlay mit 3 Tipps",       "ac": ["Given Erstlogin, When Start, Then 3 Hinweise sichtbar"],       "pattern": "Interface",       "effort": 2, "reach": 5000, "impact": 0.5, "confidence": 0.7, "bv": 4, "tc": 3, "rr": 2, "js": 2     },     {       "id": "ST4",       "title": "Erste Aufgabe abschließen",       "activity_id": "A2",       "step_id": "S22",       "description": "Mini-Aufgabe mit Erfolgserlebnis",       "depends_on": "ST3",       "ac": ["Given Aufgabe offen, When erledigt, Then Erfolgsmeldung"],       "pattern": "Operation",       "effort": 3, "reach": 5000, "impact": 2, "confidence": 0.6, "bv": 7, "tc": 4, "rr": 2, "js": 4     }   ] } path: ai-lead-story-mapping/assets/examples/example-backlog.csv id,title,description,depends_on,actor,goal,activity,step,pattern,effort,reach,impact,confidence,bv,tc,rr,js ST1,Formular E-Mail/Passwort,Basis-Registrierung,,Neukunde,Schnell registrieren und ersten Nutzen erleben,Registrieren,E-Mail & Passwort,Workflow,2,5000,2,0.8,8,6,3,3 ST2,Double-Opt-In,E-Mail-Bestätigung,ST1,Neukunde,Schnell registrieren und ersten Nutzen erleben,Registrieren,Double-Opt-In,Rule,1,5000,1,0.9,6,7,3,2 ST3,Guided Tour Overlay,Overlay mit 3 Tipps,,Neukunde,Schnell registrieren und ersten Nutzen erleben,Erste Schritte & Hilfe,Guided Tour,Interface,2,5000,0.5,0.7,4,3,2,2 ST4,Erste Aufgabe abschließen,Mini-Aufgabe mit Erfolgserlebnis,ST3,Neukunde,Schnell registrieren und ersten Nutzen erleben,Erste Schritte & Hilfe,Erste Aufgabe abschließen,Operation,3,5000,2,0.6,7,4,2,4 path: ai-lead-story-mapping/assets/examples/example-slices.md # Slices (aus Heuristik abgeleitet)  ## Slice 1 – MVP (Walking Skeleton) - ST1: Formular E‑Mail/Passwort - ST2: Double‑Opt‑In - ST3: Guided Tour Overlay - ST4: Erste Aufgabe abschließen  **Outcome & Metrik:** Aktivierungsrate D1 ≥ 30 % (TTFV ≤ 10 min)  ## Slice 2 – Komfort/Varianten - (Platz für alternative Auth, zusätzliche Tour‑Steps, etc.)  > MVP enthält mind. je kritischem Backbone‑Schritt eine Story und liefert eine durchgängige Experience (CPE). :contentReference[oaicite:36]{index=36} OPTIONAL: Bash‑Installer (Rekonstruktion lokal) #!/usr/bin/env bash set -euo pipefail mkdir -p ai-lead-story-mapping/{references,scripts,assets/templates,assets/examples} echo ">> Lege Dateien an – bitte Inhalte aus dieser Antwort in die jeweiligen Pfade kopieren." OPTIONAL: Packaging‑Hinweis Schneller Check (lokal):  python quick_validate.py ai-lead-story-mapping Paket als ZIP erstellen:  python package_skill.py ai-lead-story-mapping ./dist # oder: (cd ai-lead-story-mapping && zip -r ../ai-lead-story-mapping.zip .) Orchestrator‑Integration (Einordnung) Dieser Sub‑Skill ist so modelliert, dass der AI Lead ihn wie jeden methodischen Skill orchestriert:  Triggert Aktionen (story_map.create|slice|export_backlog|visualize)  Aggregiert Artefakte (JSON/CSV/Mermaid) für Backlog‑Gate & Priorisierung  Kapselt Workshop‑Vorgehen (Framing → Backbone → Vertikale Priorisierung → Slicing → Artefakte) nach den Quellen.  Quellenbasis (aus den angehängten Dokumenten, exemplarisch zitiert): Definition/Anatomie & Nutzen (Backbone/Vertikale Priorität, Unterschied zu flachem Backlog) und Templates/Beispiele. Workshop‑Vorgehen (Framing, Personas, Team, „walk the map“) und lebendes Artefakt.  Release‑Planung via Slicing, MVP als Walking Skeleton, Outcomes/Metriken pro Release.